From fcf8f848c43b3fe736712262fa77e5cffeda078d Mon Sep 17 00:00:00 2001
From: Javad Rahimipetroudi <javad.rahimipetroudi@mind.be>
Date: Thu, 12 Dec 2024 15:43:27 +0100
Subject: [PATCH 15/16] Emac stating for AC200

Signed-off-by: Javad Rahimipetroudi <javad.rahimipetroudi@mind.be>
---
 .../arm64/boot/dts/allwinner/sun50i-h616.dtsi | 118 ++++++-
 .../sun50i-h618-transpeed-8k618-t.dts         |  83 +++--
 .../net/ethernet/stmicro/stmmac/dwmac-sun8i.c |  12 +-
 drivers/phy/allwinner/Kconfig                 |   9 +
 drivers/phy/allwinner/Makefile                |   1 +
 drivers/phy/allwinner/ac200-ephy-ctl.c        | 301 ++++++++++++++++++
 drivers/soc/sunxi/sunxi_sram.c                |  10 +
 7 files changed, 499 insertions(+), 35 deletions(-)
 create mode 100644 drivers/phy/allwinner/ac200-ephy-ctl.c

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
index bf109449be6e..5e9953c0c3e6 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
@@ -7,8 +7,11 @@
 #include <dt-bindings/clock/sun50i-h616-ccu.h>
 #include <dt-bindings/clock/sun50i-h6-r-ccu.h>
 #include <dt-bindings/clock/sun6i-rtc.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
 #include <dt-bindings/reset/sun50i-h616-ccu.h>
 #include <dt-bindings/reset/sun50i-h6-r-ccu.h>
+#include <dt-bindings/reset/sun8i-de2.h>
 #include <dt-bindings/thermal/thermal.h>
 
 / {
@@ -100,12 +103,12 @@ reserved-memory {
 		ranges;
 
 		/*
-		 * 256 KiB reserved for Trusted Firmware-A (BL31).
+		 * 512 KiB reserved for Trusted Firmware-A (BL31).
 		 * This is added by BL31 itself, but some bootloaders fail
 		 * to propagate this into the DTB handed to kernels.
 		 */
 		secmon@40000000 {
-			reg = <0x0 0x40000000 0x0 0x40000>;
+			reg = <0x0 0x40000000 0x0 0x80000>;
 			no-map;
 		};
 	};
@@ -167,12 +170,44 @@ syscon: syscon@3000000 {
 			#size-cells = <1>;
 			ranges;
 
+			sram_a2: sram@100000 {
+				compatible = "mmio-sram";
+				reg = <0x00100000 0x18000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00100000 0x18000>;
+
+				scpi_sram: scpi-sram@17c00 {
+					compatible = "arm,scp-shmem";
+					reg = <0x17c00 0x200>;
+				};
+			};
+
 			sram_c: sram@28000 {
 				compatible = "mmio-sram";
 				reg = <0x00028000 0x30000>;
 				#address-cells = <1>;
 				#size-cells = <1>;
 				ranges = <0 0x00028000 0x30000>;
+
+				de3_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c",
+						     "allwinner,sun50i-a64-sram-c";
+					reg = <0x0000 0x1e000>;
+				};
+			};
+
+			sram_c1: sram@1a00000 {
+				compatible = "mmio-sram";
+				reg = <0x01a00000 0x200000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x01a00000 0x200000>;
+
+				ve_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c1";
+					reg = <0x000000 0x200000>;
+				};
 			};
 		};
 
@@ -403,14 +438,16 @@ gic: interrupt-controller@3021000 {
 			#interrupt-cells = <3>;
 		};
 
-		iommu: iommu@30f0000 {
-			compatible = "allwinner,sun50i-h616-iommu";
-			reg = <0x030f0000 0x10000>;
-			interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
-			clocks = <&ccu CLK_BUS_IOMMU>;
-			resets = <&ccu RST_BUS_IOMMU>;
-			#iommu-cells = <1>;
-		};
+                iommu: iommu@30f0000 {
+                        compatible = "allwinner,sun50i-h616-iommu",
+                                     "allwinner,sun50i-h6-iommu";
+                        reg = <0x030f0000 0x10000>;
+                        interrupts = <GIC_SPI 61 IRQ_TYPE_LEVEL_HIGH>;
+                        clocks = <&ccu CLK_BUS_IOMMU>;
+                        resets = <&ccu RST_BUS_IOMMU>;
+                        #iommu-cells = <1>;
+                        status = "okay";
+                };
 
 		mmc0: mmc@4020000 {
 			compatible = "allwinner,sun50i-h616-mmc",
@@ -475,6 +512,67 @@ mmc2: mmc@4022000 {
 			#size-cells = <0>;
 		};
 
+		codec: codec@05096000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-codec";
+			reg = <0x05096000 0x31c>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_AUDIO_CODEC>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			dmas = <&dma 6>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		ahub_dam_plat:ahub_dam_plat@5097000 {
+			#sound-dai-cells = <0>;
+			/* sound card without pcm for hardware mix setting */
+			compatible	= "allwinner,sunxi-snd-plat-ahub_dam";
+			reg		= <0x05097000 0x1000>;
+			resets		= <&ccu RST_BUS_AUDIO_HUB>;
+			clocks          = <&ccu CLK_AUDIO_CODEC_1X>,
+			                  <&ccu CLK_AUDIO_CODEC_4X>,
+			                  <&ccu CLK_AUDIO_HUB>,
+			                  <&ccu CLK_BUS_AUDIO_HUB>;
+			clock-names     = "clk_pll_audio",
+			                  "clk_pll_audio_4x",
+			                  "clk_audio_hub",
+			                  "clk_bus_audio_hub";
+			status		= "disabled";
+		};
+
+		ahub_dam_mach:ahub_dam_mach {
+			compatible = "allwinner,sunxi-snd-mach";
+			soundcard-mach,name = "ahubdam";
+			status		= "disabled";
+			soundcard-mach,cpu {
+				sound-dai = <&ahub_dam_plat>;
+			};
+			soundcard-mach,codec {
+			};
+		};
+
+		ahub1_plat:ahub1_plat {
+			#sound-dai-cells = <0>;
+			compatible	= "allwinner,sunxi-snd-plat-ahub";
+			apb_num		= <1>;	/* for dma port 4 */
+			dmas		= <&dma 4>, <&dma 4>;
+			dma-names	= "tx", "rx";
+			playback_cma	= <128>;
+			capture_cma	= <128>;
+			tx_fifo_size	= <128>;
+			rx_fifo_size	= <128>;
+
+			tdm_num		= <1>;
+			tx_pin		= <0>;
+			rx_pin		= <0>;
+			status		= "disabled";
+		};
+
+
 		uart0: serial@5000000 {
 			compatible = "snps,dw-apb-uart";
 			reg = <0x05000000 0x400>;
diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h618-transpeed-8k618-t.dts b/arch/arm64/boot/dts/allwinner/sun50i-h618-transpeed-8k618-t.dts
index 6afdbb0d3a84..a2b441d90099 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h618-transpeed-8k618-t.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h618-transpeed-8k618-t.dts
@@ -24,7 +24,7 @@ aliases {
 	chosen {
 		stdout-path = "serial0:115200n8";
 	};
-
+	
 	reg_vcc5v: vcc5v {
 		/* board wide 5V supply directly from the DC input */
 		compatible = "regulator-fixed";
@@ -57,6 +57,31 @@ &cpu0 {
 	cpu-supply = <&reg_dcdc2>;
 };
 
+
+&ahub_dam_plat {
+	status = "okay";
+};
+
+&ahub_dam_mach {
+	status = "okay";
+};
+
+&ahub1_plat {
+	status = "okay";
+};
+
+
+&codec {
+	allwinner,audio-routing =
+	        "Line Out", "LINEOUT";
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&reg_dcdc2>;
+	status = "okay";
+};
+
 &ehci0 {
 	status = "okay";
 };
@@ -65,10 +90,33 @@ &ehci1 {
 	status = "okay";
 };
 
+&emac1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&rmii_pins>;
+	phy-mode = "rmii";
+	phy-handle = <&rmii_phy>;
+	phy-supply = <&reg_aldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+
 &ir {
 	status = "okay";
 };
 
+&i2c3 {
+	status = "okay";
+};
+
+&mdio1 {
+	rmii_phy: ethernet-phy@16 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <16>;
+	};
+};
+
 &mmc0 {
 	vmmc-supply = <&reg_dldo1>;
 	cd-gpios = <&pio 8 16 GPIO_ACTIVE_LOW>;	/* PI16 */
@@ -178,6 +226,17 @@ &uart1 {
 	pinctrl-0 = <&uart1_pins>, <&uart1_rts_cts_pins>;
 	uart-has-rtscts;
 	status = "okay";
+
+	bluetooth {
+		compatible = "brcm,bcm43438-bt";
+		shutdown-gpios = <&pio 6 19 GPIO_ACTIVE_HIGH>; /* PG19 */
+		clocks = <&rtc CLK_OSC32K_FANOUT>;
+		host-wakeup-gpios = <&pio 6 16 GPIO_ACTIVE_HIGH>; /* PG16 */
+		clock-names = "lpo";
+		vddio-supply = <&reg_dldo1>;
+		device-wakeup-gpios = <&pio 6 17 GPIO_ACTIVE_HIGH>; /* PG17 */
+		vbat-supply = <&reg_dldo1>;
+	};
 };
 
 &usbotg {
@@ -188,25 +247,3 @@ &usbotg {
 &usbphy {
 	status = "okay";
 };
-
-&emac1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&rmii_pins>;
-	phy-mode = "rmii";
-	phy-handle = <&rmii_phy>;
-	phy-supply = <&reg_aldo1>;
-	allwinner,rx-delay-ps = <3100>;
-	allwinner,tx-delay-ps = <700>;
-	status = "okay";
-};
-
-&i2c3 {
-	status = "okay";
-};
-
-&mdio1 {
-	rmii_phy: ethernet-phy@0 {
-		compatible = "ethernet-phy-ieee802.3-c22";
-		reg = <0>;
-	};
-};
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
index 49fffe1ab8e5..7c73a70a0b54 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
@@ -1167,11 +1167,13 @@ static int sun8i_dwmac_probe(struct platform_device *pdev)
 	struct stmmac_resources stmmac_res;
 	struct sunxi_priv_data *gmac;
 	struct device *dev = &pdev->dev;
+	struct reg_field syscon_field;
 	phy_interface_t interface;
 	int ret;
 	struct stmmac_priv *priv;
 	struct net_device *ndev;
 	struct regmap *regmap;
+	u32 syscon_idx = 0;
 
 	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
 	if (ret)
@@ -1235,8 +1237,12 @@ static int sun8i_dwmac_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	gmac->regmap_field = devm_regmap_field_alloc(dev, regmap,
-						     *gmac->variant->syscon_field);
+	syscon_field = *gmac->variant->syscon_field;
+	ret = of_property_read_u32_index(pdev->dev.of_node, "syscon", 1,
+					 &syscon_idx);
+	if (!ret)
+		syscon_field.reg += syscon_idx * sizeof(u32);
+	gmac->regmap_field = devm_regmap_field_alloc(dev, regmap, syscon_field);
 	if (IS_ERR(gmac->regmap_field)) {
 		ret = PTR_ERR(gmac->regmap_field);
 		dev_err(dev, "Unable to map syscon register: %d\n", ret);
@@ -1361,6 +1367,8 @@ static const struct of_device_id sun8i_dwmac_match[] = {
 		.data = &emac_variant_a64 },
 	{ .compatible = "allwinner,sun50i-h6-emac",
 		.data = &emac_variant_h6 },
+	{ .compatible = "allwinner,sun50i-h616-emac",
+		.data = &emac_variant_h6 },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun8i_dwmac_match);
diff --git a/drivers/phy/allwinner/Kconfig b/drivers/phy/allwinner/Kconfig
index fb584518b2d0..2e8ceca4a6a9 100644
--- a/drivers/phy/allwinner/Kconfig
+++ b/drivers/phy/allwinner/Kconfig
@@ -57,3 +57,12 @@ config PHY_SUN50I_USB3
 	  part of Allwinner H6 SoC.
 
 	  This driver controls each individual USB 2+3 host PHY combo.
+
+config AC200_PHY_CTL
+	tristate "X-Power AC200 PHY control driver"
+	depends on MFD_AC200
+	depends on RESET_CONTROLLER
+	help
+	  Enable this to support the Ethernet PHY operation of the AC200
+	  mixed signal chip. This driver just enables and configures the
+	  PHY, the PHY itself is supported by a standard driver.
diff --git a/drivers/phy/allwinner/Makefile b/drivers/phy/allwinner/Makefile
index bd74901a1255..0eecec7a908a 100644
--- a/drivers/phy/allwinner/Makefile
+++ b/drivers/phy/allwinner/Makefile
@@ -3,3 +3,4 @@ obj-$(CONFIG_PHY_SUN4I_USB)		+= phy-sun4i-usb.o
 obj-$(CONFIG_PHY_SUN6I_MIPI_DPHY)	+= phy-sun6i-mipi-dphy.o
 obj-$(CONFIG_PHY_SUN9I_USB)		+= phy-sun9i-usb.o
 obj-$(CONFIG_PHY_SUN50I_USB3)		+= phy-sun50i-usb3.o
+obj-$(CONFIG_AC200_PHY_CTL)		+= ac200-ephy-ctl.o
diff --git a/drivers/phy/allwinner/ac200-ephy-ctl.c b/drivers/phy/allwinner/ac200-ephy-ctl.c
new file mode 100644
index 000000000000..8efeaf18e42c
--- /dev/null
+++ b/drivers/phy/allwinner/ac200-ephy-ctl.c
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0+
+/**
+ * syscon driver to control and configure AC200 Ethernet PHY
+ * Copyright (c) 2022 Arm Ltd.
+ *
+ * TODO's and questions:
+ * =========================
+ * - This driver is something like a syscon driver, as it controls various
+ *   bits and registers that effect other devices (the actual PHY). It's
+ *   unclear where it should live, though:
+ *   - it could be integrated into the MFD driver, but this looks messy
+ *   - it could live at the current location (drivers/phy/allwinner), but that
+ *     sounds wrong
+ *   - it could be a separate file, but in drivers/mfd
+ *   - anything else
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+
+/* macros for system ephy control 0 register */
+#define AC200_SYS_EPHY_CTL0		0x0014
+#define AC200_EPHY_RESET_INVALID	BIT(0)
+#define AC200_EPHY_SYSCLK_GATING	1
+
+/* macros for system ephy control 1 register */
+#define AC200_SYS_EPHY_CTL1		0x0016
+#define AC200_EPHY_E_EPHY_MII_IO_EN	BIT(0)
+#define AC200_EPHY_E_LNK_LED_IO_EN	BIT(1)
+#define AC200_EPHY_E_SPD_LED_IO_EN	BIT(2)
+#define AC200_EPHY_E_DPX_LED_IO_EN	BIT(3)
+
+/* macros for ephy control register */
+#define AC200_EPHY_CTL			0x6000
+#define AC200_EPHY_SHUTDOWN		BIT(0)
+#define AC200_EPHY_LED_POL		BIT(1)
+#define AC200_EPHY_CLK_SEL		BIT(2)
+#define AC200_EPHY_ADDR(x)		(((x) & 0x1F) << 4)
+#define AC200_EPHY_XMII_SEL		BIT(11)
+#define AC200_EPHY_CALIB(x)		(((x) & 0xF) << 12)
+
+struct ac200_ephy_ctl_dev {
+	struct reset_controller_dev	rcdev;
+	struct clk_hw			*gate_clk;
+	struct regmap			*regmap;
+};
+
+static struct ac200_ephy_ctl_dev *to_phy_dev(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct ac200_ephy_ctl_dev, rcdev);
+}
+
+static int ephy_ctl_reset(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+	int ret;
+
+	ret = regmap_clear_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_RESET_INVALID);
+	if (ret)
+		return ret;
+
+	/* This is going via I2C, so there is plenty of built-in delay. */
+	return regmap_set_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+			       AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_assert(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_clear_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				 AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_deassert(struct reset_controller_dev *rcdev,
+			     unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_set_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+			       AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_status(struct reset_controller_dev *rcdev, unsigned long id)
+{
+	struct ac200_ephy_ctl_dev *ac200 = to_phy_dev(rcdev);
+
+	return regmap_test_bits(ac200->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_RESET_INVALID);
+}
+
+static int ephy_ctl_reset_of_xlate(struct reset_controller_dev *rcdev,
+				   const struct of_phandle_args *reset_spec)
+{
+	if (WARN_ON(reset_spec->args_count != 0))
+		return -EINVAL;
+
+	return 0;
+}
+
+const struct reset_control_ops ephy_ctl_reset_ops = {
+	.assert		= ephy_ctl_assert,
+	.deassert	= ephy_ctl_deassert,
+	.reset		= ephy_ctl_reset,
+	.status		= ephy_ctl_status,
+};
+
+static void ac200_ephy_ctl_disable(struct ac200_ephy_ctl_dev *priv)
+{
+	regmap_write(priv->regmap, AC200_EPHY_CTL, AC200_EPHY_SHUTDOWN);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL1, 0);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL0, 0);
+}
+
+static int ac200_ephy_ctl_probe(struct platform_device *pdev)
+{
+	struct reset_controller_dev *rcdev;
+	struct device *dev = &pdev->dev;
+	struct ac200_ephy_ctl_dev *priv;
+	struct nvmem_cell *calcell;
+	const char *parent_name;
+	phy_interface_t phy_if;
+	u16 *caldata, ephy_ctl;
+	struct clk *clk;
+	size_t callen;
+	u32 value;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->regmap = dev_get_regmap(dev->parent, NULL);
+	if (!priv->regmap)
+		return -EPROBE_DEFER;
+
+	calcell = devm_nvmem_cell_get(dev, "calibration");
+	if (IS_ERR(calcell))
+		return dev_err_probe(dev, PTR_ERR(calcell),
+				     "Unable to find calibration data!\n");
+
+	caldata = nvmem_cell_read(calcell, &callen);
+	if (IS_ERR(caldata)) {
+		dev_err(dev, "Unable to read calibration data!\n");
+		return PTR_ERR(caldata);
+	}
+
+	if (callen != 2) {
+		dev_err(dev, "Calibration data length must be 2 bytes!\n");
+		kfree(caldata);
+		return -EINVAL;
+	}
+
+	ephy_ctl = AC200_EPHY_CALIB(*caldata + 3);
+	kfree(caldata);
+
+	ret = of_get_phy_mode(dev->of_node, &phy_if);
+	if (ret) {
+		dev_err(dev, "Unable to read PHY connection mode\n");
+		return ret;
+	}
+
+	switch (phy_if) {
+	case PHY_INTERFACE_MODE_MII:
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		ephy_ctl |= AC200_EPHY_XMII_SEL;
+		break;
+	default:
+		dev_err(dev, "Illegal PHY connection mode (%d), only RMII or MII supported\n",
+			phy_if);
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "x-powers,led-polarity",
+				   &value);
+	if (ret) {
+		dev_err(dev, "Unable to read LED polarity setting\n");
+		return ret;
+	}
+
+	if (value == GPIO_ACTIVE_LOW)
+		ephy_ctl |= AC200_EPHY_LED_POL;
+
+	ret = of_property_read_u32(dev->of_node, "phy-address", &value);
+	if (ret) {
+		dev_err(dev, "Unable to read PHY address value\n");
+		return ret;
+	}
+
+	ephy_ctl |= AC200_EPHY_ADDR(value);
+
+	clk = clk_get(dev->parent, NULL);
+	if (IS_ERR(clk))
+		return dev_err_probe(dev, PTR_ERR(clk),
+				     "Unable to obtain the clock\n");
+
+	if (clk_get_rate(clk) == 24000000)
+		ephy_ctl |= AC200_EPHY_CLK_SEL;
+
+	clk_put(clk);
+
+	/* Assert reset and gate clock, to disable PHY for now */
+	ret = regmap_write(priv->regmap, AC200_SYS_EPHY_CTL0, 0);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, AC200_SYS_EPHY_CTL1,
+			   AC200_EPHY_E_EPHY_MII_IO_EN |
+			   AC200_EPHY_E_LNK_LED_IO_EN |
+			   AC200_EPHY_E_SPD_LED_IO_EN |
+			   AC200_EPHY_E_DPX_LED_IO_EN);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(priv->regmap, AC200_EPHY_CTL, ephy_ctl);
+	if (ret)
+		return ret;
+
+	rcdev = &priv->rcdev;
+	rcdev->owner = dev->driver->owner;
+	rcdev->nr_resets = 1;
+	rcdev->ops = &ephy_ctl_reset_ops;
+	rcdev->of_node = dev->of_node;
+	rcdev->of_reset_n_cells = 0;
+	rcdev->of_xlate = ephy_ctl_reset_of_xlate;
+
+	ret = devm_reset_controller_register(dev, rcdev);
+	if (ret) {
+		dev_err(dev, "Unable to register reset controller: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	parent_name = of_clk_get_parent_name(dev->parent->of_node, 0);
+	priv->gate_clk = devm_clk_hw_register_regmap_gate(dev,
+				"ac200-ephy-ctl-gate", parent_name, 0,
+				priv->regmap, AC200_SYS_EPHY_CTL0,
+				AC200_EPHY_SYSCLK_GATING, 0);
+	if (IS_ERR(priv->gate_clk)) {
+		ret = PTR_ERR(priv->gate_clk);
+		dev_err(dev, "Unable to register gate clock: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	ret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get,
+					  priv->gate_clk);
+	if (ret) {
+		dev_err(dev, "Unable to register clock provider: %d\n", ret);
+		goto err_disable_ephy;
+	}
+
+	return 0;
+
+err_disable_ephy:
+	ac200_ephy_ctl_disable(priv);
+
+	return ret;
+}
+
+static int ac200_ephy_ctl_remove(struct platform_device *pdev)
+{
+	struct ac200_ephy_ctl_dev *priv = platform_get_drvdata(pdev);
+
+	ac200_ephy_ctl_disable(priv);
+
+	return 0;
+}
+
+static const struct of_device_id ac200_ephy_ctl_match[] = {
+	{ .compatible = "x-powers,ac200-ephy-ctl" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ac200_ephy_ctl_match);
+
+static struct platform_driver ac200_ephy_ctl_driver = {
+	.probe		= ac200_ephy_ctl_probe,
+	.remove		= ac200_ephy_ctl_remove,
+	.driver		= {
+		.name		= "ac200-ephy-ctl",
+		.of_match_table	= ac200_ephy_ctl_match,
+	},
+};
+module_platform_driver(ac200_ephy_ctl_driver);
+
+MODULE_AUTHOR("Andre Przywara <andre.przywara@arm.com>");
+MODULE_DESCRIPTION("AC200 Ethernet PHY control driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/sunxi/sunxi_sram.c b/drivers/soc/sunxi/sunxi_sram.c
index 2781a091a6a6..08e264ea0697 100644
--- a/drivers/soc/sunxi/sunxi_sram.c
+++ b/drivers/soc/sunxi/sunxi_sram.c
@@ -69,6 +69,12 @@ static struct sunxi_sram_desc sun4i_a10_sram_c1 = {
 				  SUNXI_SRAM_MAP(0x7fffffff, 1, "ve")),
 };
 
+static struct sunxi_sram_desc sun50i_h616_sram_c1 = {
+	.data	= SUNXI_SRAM_DATA("C1", 0x0, 0x0, 31,
+				  SUNXI_SRAM_MAP(0x7fffffff, 0, "cpu"),
+				  SUNXI_SRAM_MAP(0, 1, "ve")),
+};
+
 static struct sunxi_sram_desc sun4i_a10_sram_d = {
 	.data	= SUNXI_SRAM_DATA("D", 0x4, 0x0, 1,
 				  SUNXI_SRAM_MAP(0, 0, "cpu"),
@@ -98,6 +104,10 @@ static const struct of_device_id sunxi_sram_dt_ids[] = {
 		.compatible	= "allwinner,sun50i-a64-sram-c",
 		.data		= &sun50i_a64_sram_c.data,
 	},
+	{
+		.compatible	= "allwinner,sun50i-h616-sram-c1",
+		.data		= &sun50i_h616_sram_c1.data,
+	},
 	{}
 };
 
-- 
2.47.1

